\section{Introduction}

%\subsection{}
%
\begin{frame}{Problem Statement}  
  \begin{itemize}
    \item Our work aims at \ldots
    \item More\dots
  \end{itemize}
  \vfill
  A whitespace gap\\
  \begin{tiny}
    Smaller Font
  \end{tiny}
\end{frame}
%
%------------------------------
\begin{frame}[label=1]{AMR Programming}
  \begin{itemize}
    \item
      The software running on \red{A}utonomous \red{M}obile \red{R}obots
      requires the execution of many different tasks.
\N  
    \item
      \red{Low level} tasks, such as control loops for mechanical arms 
      and motion, are commonly written in \purple{C} or 
      \purple{assembly}.
    \item
    In designing \red{higher level} tasks, such as path planning 
    or strategy control, a trade-off between \purple{efficiency} and 
    \purple{maintainability} is critical.
\N
  \end{itemize}
\N
\end{frame}
%------------------------------


%------------------------------
\begin{frame}[label=2]{The ``Mixture''}
  \begin{itemize}
    \item
      Designing strategies with an imperative approach implies the use of a \red{F}inite-\red{S}tate \red{M}achine
    \item
      When the strategy increases in complexity, imperative source code quickly becomes very hard to maintain.
\pause
    \N\N
    \item
    The \red{logic}/\red{declarative} approach employs a model closer to human reasoning process 
\N    
 

\item
    However, mixing different languages and paradigms in the same system arises serious efficiency issues.
 

\end{itemize}
\N\N
\end{frame}
%------------------------------



